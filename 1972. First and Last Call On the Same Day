Table: Calls

+--------------+----------+
| Column Name  | Type     |
+--------------+----------+
| caller_id    | int      |
| recipient_id | int      |
| call_time    | datetime |
+--------------+----------+
(caller_id, recipient_id, call_time) is the primary key (combination of columns with unique values) for this table.
Each row contains information about the time of a phone call between caller_id and recipient_id.
 

Write a solution to report the IDs of the users whose first and last calls on any day were with the same person. Calls are counted regardless of being the caller or the recipient.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Calls table:
+-----------+--------------+---------------------+
| caller_id | recipient_id | call_time           |
+-----------+--------------+---------------------+
| 8         | 4            | 2021-08-24 17:46:07 |
| 4         | 8            | 2021-08-24 19:57:13 |
| 5         | 1            | 2021-08-11 05:28:44 |
| 8         | 3            | 2021-08-17 04:04:15 |
| 11        | 3            | 2021-08-17 13:07:00 |
| 8         | 11           | 2021-08-17 22:22:22 |
+-----------+--------------+---------------------+
Output: 
+---------+
| user_id |
+---------+
| 1       |
| 4       |
| 5       |
| 8       |
+---------+
Explanation: 
On 2021-08-24, the first and last call of this day for user 8 was with user 4. User 8 should be included in the answer.
Similarly, user 4 on 2021-08-24 had their first and last call with user 8. User 4 should be included in the answer.
On 2021-08-11, user 1 and 5 had a call. This call was the only call for both of them on this day. Since this call is the first and last call of the day for both of them, they should both be included in the answer.

SOLUTION 
Consider the Following Conditions Carefully 
1.The first and last call made by the user is on for the same user
2.The user called just one user but the second user called multiple people so there call count for the day =1 will also be considered

# Write your MySQL query statement below
with cte as(
select id ,DATE(call_time) as dates ,count(distinct recipient_id) as d,
MAX(CALL_TIME) AS ma,MIN(CALL_TIME) as mi from (
select caller_id as id,recipient_id,call_time 
from Calls
union all 
select recipient_id as id,caller_id,call_time 
from Calls
)s
group by id,dates
order  BY dates
)


select * from (
(
select distinct a.id as user_id from cte  as a join 
(
select dates,ma,mi
from cte
group by dates,ma,mi
having count(*)>=2
) as b
on a.dates=b.dates and a.ma=b.ma and a.mi=b.mi
)

union 
(
    select id from cte where d=1
)
) s
order by user_id 

Approach: Dual-Ranking Unified Call Analysis
The "Dual-Ranking Unified Call Analysis" approach utilizes a combination of SQL Common Table Expressions (CTEs) and window functions to identify users whose first and last calls each day are with the same person. Initially, it constructs a unified view of calls by treating each user as a participant, regardless of whether they are a caller or recipient. Subsequently, it employs dual-ranking to determine each user's earliest and latest calls per day. Finally, the approach filters and groups this data to isolate users who interacted with the same individual in both their first and last calls of any given day.

Intuition
Here's a breakdown of the logic:

Let's break down the SQL query step by step and explain the intuition behind each part:

Creating a Unified View of Calls (CTE: UnifiedCalls)
The goal of this step is to consider each user as a participant in a call, regardless of whether they are the caller or the recipient.
This allows us to later analyze calls by focusing solely on the user_id, without worrying about whether they were the caller or the recipient in the original data.
WITH UnifiedCalls AS (
  -- Include calls where the user is the caller
  SELECT 
    caller_id AS user_id, 
    call_time, 
    recipient_id AS other_participant_id 
  FROM 
    Calls 
  UNION 
    -- Include calls where the user is the recipient
  SELECT 
    recipient_id AS user_id, 
    call_time, 
    caller_id AS other_participant_id 
  FROM 
    Calls
)
We create two SELECT statements within a CTE named UnifiedCalls.
The first SELECT transforms rows from the Calls table by treating the caller_id as user_id and keeping the recipient_id as other_participant_id.
The second SELECT does the opposite: it treats the recipient_id as user_id and the caller_id as other_participant_id.
We use the UNION operator to combine these two sets of results. This ensures every call is represented twice: once from the perspective of the caller and once from the perspective of the recipient.
Ranking Calls for Each User on Each Day (CTE: RankedCalls)
The goal of this step is to identify the first and last calls made by each user on each day.
These rankings allow us to easily identify the first and last calls of each day for each user, as they will have ranks 1 in their respective ordering.
RankedCalls AS (
  SELECT 
    user_id, 
    other_participant_id, 
    DATE(call_time) AS call_date, 
    -- Extracting just the date part of call_time
    DENSE_RANK() OVER (
      PARTITION BY user_id, 
      DATE(call_time) 
      ORDER BY 
        call_time ASC
    ) AS rank_earliest_call, 
    DENSE_RANK() OVER (
      PARTITION BY user_id, 
      DATE(call_time) 
      ORDER BY 
        call_time DESC
    ) AS rank_latest_call 
  FROM 
    UnifiedCalls
)
We create a CTE named RankedCalls where we use the DENSE_RANK() window function twice.
The first use of DENSE_RANK() (named as rank_earliest_call) ranks calls for each user_id and call_date (date part of call_time) in ascending order of call_time. The earliest call of the day gets the rank 1.
The second use of DENSE_RANK() (named as rank_latest_call) ranks the same calls but in descending order of call_time. The latest call of the day gets the rank 1.
Selecting Users with Matching Call Partners on the Same Day
The goal of this step is to find users whose first and last calls of the day were with the same person.
This step is key to solving the problem. It filters down to users who started and ended their calling day with the same person, as required by the problem statement.
SELECT 
  DISTINCT user_id 
FROM 
  RankedCalls 
WHERE 
  rank_earliest_call = 1 
  OR rank_latest_call = 1 -- Filtering for first and last calls
GROUP BY 
  user_id, 
  call_date 
HAVING 
  COUNT(DISTINCT other_participant_id) = 1;
In the final SELECT statement, we filter out rows from RankedCalls where the rank is either 1 in ascending order (rank_earliest_call) or 1 in descending order (rank_latest_call). This effectively selects the first and last calls of each user for each day.
We then group the results by user_id and call_date.
The HAVING COUNT(DISTINCT other_participant_id) = 1 clause is crucial. It ensures that for each group (user-day combination), there is only one distinct other_participant_id for both the first and last calls. In other words, the user's first and last calls of the day were with the same person.
Implementation
-- CTE to create a unified view of all calls, treating each user as a 'participant'
WITH UnifiedCalls AS (
  -- Include calls where the user is the caller
  SELECT 
    caller_id AS user_id, 
    call_time, 
    recipient_id AS other_participant_id 
  FROM 
    Calls 
  UNION 
    -- Include calls where the user is the recipient
  SELECT 
    recipient_id AS user_id, 
    call_time, 
    caller_id AS other_participant_id 
  FROM 
    Calls
), 
-- CTE to rank the calls for each user on each day
RankedCalls AS (
  SELECT 
    user_id, 
    other_participant_id, 
    DATE(call_time) AS call_date, 
    -- Extracting just the date part of call_time
    DENSE_RANK() OVER (
      PARTITION BY user_id, 
      DATE(call_time) 
      ORDER BY 
        call_time ASC
    ) AS rank_earliest_call, 
    DENSE_RANK() OVER (
      PARTITION BY user_id, 
      DATE(call_time) 
      ORDER BY 
        call_time DESC
    ) AS rank_latest_call 
  FROM 
    UnifiedCalls
) -- Selecting users whose first and last calls of the day were with the same person
SELECT 
  DISTINCT user_id 
FROM 
  RankedCalls 
WHERE 
  rank_earliest_call = 1 
  OR rank_latest_call = 1 -- Filtering for first and last calls
GROUP BY 
  user_id, 
  call_date 
HAVING 
  COUNT(DISTINCT other_participant_id) = 1;

